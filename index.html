<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Змейка — Расширенная версия для Telegram</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  body {
    margin: 0; padding: 0; background: #111; color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    touch-action: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: linear-gradient(135deg, #050, #020);
    box-shadow: 0 0 20px #0a0;
    touch-action: none;
    max-width: 100%;
    max-height: 100vh;
    width: 100%;
    height: auto;
  }
  #menu, #game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 15px;
    box-shadow: 0 0 15px #0a0;
    width: 80%;
    max-width: 300px;
  }
  #menu h1, #game-over h1 {
    font-size: 28px;
    margin: 10px 0;
    color: #0f0;
    text-shadow: 0 0 8px #0f0;
  }
  select, button {
    font-size: 16px;
    margin: 5px;
    padding: 8px 16px;
    border-radius: 10px;
    border: none;
    background: linear-gradient(135deg, #2a2, #060);
    color: #dff;
    cursor: pointer;
    box-shadow: 0 3px 8px #060;
    transition: background 0.3s ease;
    width: 80%;
  }
  select:hover, button:hover {
    background: linear-gradient(135deg, #4d4, #090);
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="menu">
  <h1>Змейка</h1>
  <select id="skinSelect">
    <option value="classic">Классический</option>
    <option value="green">Зелёный</option>
    <option value="rainbow">Радуга</option>
  </select>
  <select id="speedSelect">
    <option value="14">Медленно</option>
    <option value="12">Нормально</option>
    <option value="8">Быстро</option>
  </select>
  <button id="startBtn">Начать игру</button>
</div>

<div id="game-over" style="display: none;">
  <h1>Игра окончена</h1>
  <p id="finalScore">Очки: 0</p>
  <p id="highScore">Рекорд: 0</p>
  <button id="playAgainBtn">Играть снова</button>
</div>

<script>
(() => {
  const tg = window.Telegram.WebApp;
  tg.ready();
  tg.expand();

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const box = 20;

  // Адаптация размера canvas
  const maxSize = Math.min(window.innerWidth, window.innerHeight);
  const gridSize = Math.floor(maxSize / box) * box;
  canvas.width = gridSize;
  canvas.height = gridSize;

  let snake = [];
  let direction = 'RIGHT';
  let food = {};
  let score = 0;
  let highScore = localStorage.getItem('snakeHighScore') ? parseInt(localStorage.getItem('snakeHighScore')) : 0;
  let skin = 'classic';
  let animationSteps = 8;
  let animationProgress = 0;
  let prevPositions = [];
  let particles = [];
  let gameStarted = false;
  let gamePaused = false;

  // Сенсорный ввод
  let touchStartX = 0;
  let touchStartY = 0;

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (gamePaused) {
      gamePaused = false;
      mainLoop();
      return;
    }
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (!gameStarted || gamePaused) return;
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    const threshold = 20;

    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
      if (dx > 0 && direction !== 'LEFT') direction = 'RIGHT';
      else if (dx < 0 && direction !== 'RIGHT') direction = 'LEFT';
    } else if (Math.abs(dy) > threshold) {
      if (dy > 0 && direction !== 'UP') direction = 'DOWN';
      else if (dy < 0 && direction !== 'DOWN') direction = 'UP';
    }
  }, { passive: false });

  function initGame() {
    snake = [
      {x: Math.floor(canvas.width / (2 * box)) * box, y: Math.floor(canvas.height / (2 * box)) * box},
      {x: Math.floor(canvas.width / (2 * box) - 1) * box, y: Math.floor(canvas.height / (2 * box)) * box},
      {x: Math.floor(canvas.width / (2 * box) - 2) * box, y: Math.floor(canvas.height / (2 * box)) * box}
    ];
    direction = 'RIGHT';
    score = 0;
    animationProgress = 0;
    prevPositions = snake.map(s => ({...s}));
    food = randomFood();
    gamePaused = false;
    document.getElementById('menu').style.display = 'none';
    document.getElementById('game-over').style.display = 'none';
  }

  function randomFood() {
    let x, y, collision;
    do {
      x = Math.floor(Math.random() * (canvas.width / box)) * box;
      y = Math.floor(Math.random() * (canvas.height / box)) * box;
      collision = snake.some(seg => seg.x === x && seg.y === y);
    } while (collision);
    return {x, y};
  }

  function drawScore() {
    ctx.font = '20px Segoe UI';
    ctx.fillStyle = '#0f0';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText('Очки: ' + score, 10, 10);
    ctx.fillText('Рекорд: ' + highScore, 10, 30);
    if (gamePaused) {
      ctx.font = '30px Segoe UI';
      ctx.fillStyle = '#0f0';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Пауза (тап для продолжения)', canvas.width / 2, canvas.height / 2);
    }
  }

  function handleKey(e) {
    if (e.key === ' ') {
      if (gameStarted && !gamePaused) {
        gamePaused = true;
      } else if (gameStarted && gamePaused) {
        gamePaused = false;
        mainLoop();
      }
      return;
    }
    if (!gameStarted || gamePaused) return;
    if (e.key === 'ArrowLeft' && direction !== 'RIGHT') direction = 'LEFT';
    else if (e.key === 'ArrowRight' && direction !== 'LEFT') direction = 'RIGHT';
    else if (e.key === 'ArrowUp' && direction !== 'DOWN') direction = 'UP';
    else if (e.key === 'ArrowDown' && direction !== 'UP') direction = 'DOWN';
  }

  function moveSnake() {
    if (!gameStarted || gamePaused) return true;
    if (animationProgress < animationSteps) {
      animationProgress++;
    } else {
      animationProgress = 0;
      let head = {...snake[0]};
      switch(direction) {
        case 'LEFT': head.x -= box; break;
        case 'RIGHT': head.x += box; break;
        case 'UP': head.y -= box; break;
        case 'DOWN': head.y += box; break;
      }
      if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
        gameOver();
        return false;
      }
      if (snake.some((seg, i) => i > 0 && seg.x === head.x && seg.y === head.y)) {
        gameOver();
        return false;
      }
      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score++;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('snakeHighScore', highScore);
        }
        createParticles(food.x, food.y, '#ff4444');
        food = randomFood();
      } else {
        snake.pop();
      }
      prevPositions = snake.map(s => ({...s}));
    }
    return true;
  }

  function drawSnake() {
    for (let i = 0; i < snake.length; i++) {
      const from = prevPositions[i] || snake[i];
      const to = snake[i];
      const lerpX = from.x + (to.x - from.x) * (animationProgress / animationSteps);
      const lerpY = from.y + (to.y - from.y) * (animationProgress / animationSteps);

      let color;
      if (skin === 'classic') {
        color = i === 0 ? '#0f0' : '#070';
      } else if (skin === 'green') {
        color = `hsl(${(i * 30) % 120 + 60}, 100%, 40%)`;
      } else if (skin === 'rainbow') {
        color = `hsl(${(i * 20) % 360}, 100%, 50%)`;
      }

      const grad = ctx.createLinearGradient(lerpX, lerpY, lerpX, lerpY + box);
      grad.addColorStop(0, color);
      grad.addColorStop(1, '#003300');
      ctx.fillStyle = grad;

      ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;

      ctx.fillRect(lerpX, lerpY, box, box);

      ctx.shadowColor = 'transparent';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.strokeRect(lerpX, lerpY, box, box);
    }
  }

  let foodScale = 1;
  let foodScaleDirection = 1;

  function drawFood() {
    const {x, y} = food;

    foodScale += foodScaleDirection * 0.015;
    if (foodScale > 1.2) foodScaleDirection = -1;
    else if (foodScale < 0.9) foodScaleDirection = 1;

    ctx.save();
    ctx.translate(x + box/2, y + box/2);
    ctx.scale(foodScale, foodScale);
    ctx.translate(-box/2, -box/2);

    let grad = ctx.createRadialGradient(box/2, box/2, 2, box/2, box/2, box/2);
    grad.addColorStop(0, '#ff6666');
    grad.addColorStop(1, '#990000');
    ctx.fillStyle = grad;

    ctx.shadowColor = '#ff4444';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    ctx.beginPath();
    ctx.arc(box/2, box/2, box/2 - 2, 0, 2 * Math.PI);
    ctx.fill();

    ctx.restore();
  }

  function createParticles(x, y, color) {
    for (let i = 0; i < 10; i++) {
      particles.push({
        x: x + box/2,
        y: y + box/2,
        vx: (Math.random() - 0.5) * 3,
        vy: (Math.random() - 0.5) * 3,
        life: 15 + Math.random()*8,
        color: color,
        size: 2 + Math.random()*2,
      });
    }
  }

  function drawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
      ctx.fill();

      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      p.size *= 0.96;

      if (p.life <= 0 || p.size < 0.1) particles.splice(i, 1);
    }
  }

  function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawFood();
    drawSnake();
    drawParticles();
    drawScore();
  }

  function gameOver() {
    gameStarted = false;
    document.getElementById('finalScore').textContent = 'Очки: ' + score;
    document.getElementById('highScore').textContent = 'Рекорд: ' + highScore;
    document.getElementById('game-over').style.display = 'block';
  }

  function mainLoop() {
    if (moveSnake()) {
      drawGame();
      requestAnimationFrame(mainLoop);
    }
  }

  // Инициализация меню и обработчики
  document.getElementById('startBtn').addEventListener('click', () => {
    skin = document.getElementById('skinSelect').value;
    animationSteps = parseInt(document.getElementById('speedSelect').value);
    gameStarted = true;
    initGame();
    mainLoop();
  });

  document.getElementById('playAgainBtn').addEventListener('click', () => {
    skin = document.getElementById('skinSelect').value;
    animationSteps = parseInt(document.getElementById('speedSelect').value);
    gameStarted = true;
    initGame();
    mainLoop();
  });

  document.getElementById('skinSelect').addEventListener('change', () => {
    skin = document.getElementById('skinSelect').value;
  });

  document.getElementById('speedSelect').addEventListener('change', () => {
    animationSteps = parseInt(document.getElementById('speedSelect').value);
  });

  window.addEventListener('keydown', handleKey);

  // Показать меню при загрузке
  document.getElementById('menu').style.display = 'block';
  document.getElementById('game-over').style.display = 'none';

  initGame();
})();
</script>

</body>
</html>
