<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Змейка — Telegram Mini App</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            user-select: none;
            transition: background-color 0.3s, color 0.3s;
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            max-height: 600px;
            margin: auto;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }
        #score {
            text-align: center;
            font-size: 24px;
            font-weight: 700;
            margin: 10px auto;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            border-radius: 15px;
        }
        #start-screen.visible, #game-over-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }
        h1, h2 {
            margin: 10px 0;
            font-size: 24px;
            text-align: center;
        }
        p {
            margin: 5px 0;
            font-size: 16px;
        }
        button, select {
            font-size: 18px;
            margin: 5px;
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
        }
        button:hover, select:hover {
            transform: scale(1.05);
        }
        #mobile-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }
        #mobile-controls button {
            font-size: 28px;
            width: 60px;
            height: 60px;
            margin: 5px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game"></canvas>
        <div id="start-screen" class="visible">
            <h1>Змейка</h1>
            <p>Лучший счёт: <span id="best-score">0</span></p>
            <select id="skinSelect">
                <option value="classic">Классический</option>
                <option value="green">Зелёный</option>
                <option value="rainbow">Радуга</option>
            </select>
            <button id="startBtn">Начать игру</button>
        </div>
        <div id="game-over-screen">
            <h2>Game Over</h2>
            <p>Счёт: <span id="final-score">0</span></p>
            <p>Лучший счёт: <span id="best-score-go">0</span></p>
        </div>
        <div id="score">Очки: 0</div>
        <div id="mobile-controls">
            <button id="upBtn">↑</button>
            <button id="leftBtn">←</button>
            <button id="downBtn">↓</button>
            <button id="rightBtn">→</button>
        </div>
    </div>

    <script>
        (() => {
            // Инициализация Telegram Web App
            const webApp = window.Telegram ? window.Telegram.WebApp : null;
            if (webApp) {
                webApp.ready();
                webApp.expand();
                webApp.MainButton.setText('Играть снова').hide();
            }

            // Тема Telegram
            const themeParams = webApp ? webApp.themeParams : {};
            const bgColor = themeParams.bg_color || '#111';
            const textColor = themeParams.text_color || '#eee';
            const buttonColor = themeParams.button_color || '#2a2';
            const buttonTextColor = themeParams.button_text_color || '#dff';
            const secondaryBgColor = themeParams.secondary_bg_color || '#050';

            document.body.style.backgroundColor = bgColor;
            document.body.style.color = textColor;
            document.querySelectorAll('button, select').forEach(el => {
                el.style.background = `linear-gradient(135deg, ${buttonColor}, ${secondaryBgColor})`;
                el.style.color = buttonTextColor;
            });
            document.querySelector('#game').style.background = `linear-gradient(135deg, ${secondaryBgColor}, #020)`;
            document.querySelectorAll('#start-screen, #game-over-screen').forEach(el => {
                el.style.backgroundColor = `rgba(${parseInt(secondaryBgColor.slice(1,3),16)}, ${parseInt(secondaryBgColor.slice(3,5),16)}, ${parseInt(secondaryBgColor.slice(5,7),16)}, 0.8)`;
            });

            // Инициализация Canvas
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const box = 30;

            function resizeCanvas() {
                const size = Math.min(window.innerWidth, window.innerHeight - 100) * 0.9;
                canvas.width = Math.floor(size / box) * box;
                canvas.height = canvas.width;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            if (webApp) webApp.onEvent('viewportChanged', resizeCanvas);

            let snake = [];
            let direction = 'RIGHT';
            let food = {};
            let score = 0;
            let bestScore = localStorage.getItem('bestScore') || 0;
            let skin = 'classic';
            const animationSteps = 5;
            let animationProgress = 0;
            let prevPositions = [];
            const particles = [];

            document.getElementById('best-score').textContent = bestScore;
            document.getElementById('best-score-go').textContent = bestScore;

            function initGame() {
                console.log('Initializing game...');
                snake = [
                    { x: 9 * box, y: 10 * box },
                    { x: 8 * box, y: 10 * box },
                    { x: 7 * box, y: 10 * box }
                ];
                direction = 'RIGHT';
                score = 0;
                animationProgress = 0;
                prevPositions = snake.map(s => ({ ...s }));
                food = randomFood();
                updateScore();
                document.getElementById('start-screen').classList.remove('visible');
                document.getElementById('game-over-screen').classList.remove('visible');
                if (webApp) webApp.MainButton.hide();
            }

            function randomFood() {
                let x, y, collision;
                do {
                    x = Math.floor(Math.random() * (canvas.width / box)) * box;
                    y = Math.floor(Math.random() * (canvas.height / box)) * box;
                    collision = snake.some(seg => seg.x === x && seg.y === y);
                } while (collision);
                return { x, y };
            }

            function updateScore() {
                document.getElementById('score').textContent = `Очки: ${score}`;
                document.getElementById('final-score').textContent = score;
                if (score > bestScore) {
                    bestScore = score;
                    localStorage.setItem('bestScore', bestScore);
                    document.getElementById('best-score').textContent = bestScore;
                    document.getElementById('best-score-go').textContent = bestScore;
                }
            }

            function handleKey(e) {
                if (e.key === 'ArrowLeft' && direction !== 'RIGHT') direction = 'LEFT';
                else if (e.key === 'ArrowRight' && direction !== 'LEFT') direction = 'RIGHT';
                else if (e.key === 'ArrowUp' && direction !== 'DOWN') direction = 'UP';
                else if (e.key === 'ArrowDown' && direction !== 'UP') direction = 'DOWN';
            }

            // Свайпы для мобильных устройств
            let touchStartX = 0, touchStartY = 0;
            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touchEndX = e.touches[0].clientX;
                const touchEndY = e.touches[0].clientY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0 && direction !== 'LEFT') direction = 'RIGHT';
                    else if (dx < 0 && direction !== 'RIGHT') direction = 'LEFT';
                } else {
                    if (dy > 0 && direction !== 'UP') direction = 'DOWN';
                    else if (dy < 0 && direction !== 'DOWN') direction = 'UP';
                }
            });

            function moveSnake() {
                if (animationProgress < animationSteps) {
                    animationProgress++;
                } else {
                    animationProgress = 0;
                    let head = { ...snake[0] };
                    switch (direction) {
                        case 'LEFT': head.x -= box; break;
                        case 'RIGHT': head.x += box; break;
                        case 'UP': head.y -= box; break;
                        case 'DOWN': head.y += box; break;
                    }
                    // Проверка границ (без бесконечных стен для простоты)
                    if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
                        gameOver();
                        return false;
                    }
                    if (snake.some((seg, i) => i > 0 && seg.x === head.x && seg.y === head.y)) {
                        gameOver();
                        return false;
                    }
                    snake.unshift(head);
                    if (head.x === food.x && head.y === food.y) {
                        score++;
                        updateScore();
                        createParticles(food.x, food.y, '#ff4444');
                        food = randomFood();
                        if ('vibrate' in navigator) navigator.vibrate(100);
                    } else {
                        snake.pop();
                    }
                    prevPositions = snake.map(s => ({ ...s }));
                }
                return true;
            }

            function drawSnake() {
                for (let i = 0; i < snake.length; i++) {
                    const from = prevPositions[i] || snake[i];
                    const to = snake[i];
                    const lerpX = from.x + (to.x - from.x) * (animationProgress / animationSteps);
                    const lerpY = from.y + (to.y - from.y) * (animationProgress / animationSteps);
                    let color;
                    if (skin === 'classic') {
                        color = i === 0 ? '#0f0' : '#070';
                    } else if (skin === 'green') {
                        color = `hsl(${(i * 30) % 120 + 60}, 100%, 40%)`;
                    } else if (skin === 'rainbow') {
                        color = `hsl(${(i * 20) % 360}, 100%, 50%)`;
                    }
                    const grad = ctx.createLinearGradient(lerpX, lerpY, lerpX, lerpY + box);
                    grad.addColorStop(0, color);
                    grad.addColorStop(1, '#003300');
                    ctx.fillStyle = grad;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                    ctx.shadowBlur = 6;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.fillRect(lerpX, lerpY, box, box);
                    ctx.shadowColor = 'transparent';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(lerpX, lerpY, box, box);
                }
            }

            let foodScale = 1;
            let foodScaleDirection = 1;

            function drawFood() {
                const { x, y } = food;
                foodScale += foodScaleDirection * 0.02;
                if (foodScale > 1.3) foodScaleDirection = -1;
                else if (foodScale < 1) foodScaleDirection = 1;
                ctx.save();
                ctx.translate(x + box / 2, y + box / 2);
                ctx.scale(foodScale, foodScale);
                ctx.translate(-box / 2, -box / 2);
                let grad = ctx.createRadialGradient(box / 2, box / 2, 2, box / 2, box / 2, box / 2);
                grad.addColorStop(0, '#ff6666');
                grad.addColorStop(1, '#990000');
                ctx.fillStyle = grad;
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.beginPath();
                ctx.arc(box / 2, box / 2, box / 2 - 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
            }

            function createParticles(x, y, color) {
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: x + box / 2,
                        y: y + box / 2,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 20 + Math.random() * 10,
                        color: color,
                        size: 3 + Math.random() * 3,
                    });
                }
            }

            function drawParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                    ctx.fill();
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    p.size *= 0.95;
                    if (p.life <= 0 || p.size < 0.1) particles.splice(i, 1);
                }
            }

            function drawGame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawFood();
                drawSnake();
                drawParticles();
            }

            function gameOver() {
                document.getElementById('game-over-screen').classList.add('visible');
                if (webApp) {
                    webApp.MainButton.show();
                    webApp.MainButton.onClick(() => {
                        document.getElementById('game-over-screen').classList.remove('visible');
                        document.getElementById('start-screen').classList.add('visible');
                        webApp.MainButton.hide();
                    });
                }
                if ('vibrate' in navigator) navigator.vibrate([200, 100, 200]);
            }

            function mainLoop() {
                if (moveSnake()) {
                    drawGame();
                    requestAnimationFrame(mainLoop);
                }
            }

            document.getElementById('upBtn').onclick = () => { if (direction !== 'DOWN') direction = 'UP'; };
            document.getElementById('downBtn').onclick = () => { if (direction !== 'UP') direction = 'DOWN'; };
            document.getElementById('leftBtn').onclick = () => { if (direction !== 'RIGHT') direction = 'LEFT'; };
            document.getElementById('rightBtn').onclick = () => { if (direction !== 'LEFT') direction = 'RIGHT'; };

            window.addEventListener('keydown', handleKey);

            document.getElementById('startBtn').onclick = () => {
                console.log('Start button clicked');
                skin = document.getElementById('skinSelect').value;
                initGame();
                mainLoop();
            };

            initGame();
        })();
    </script>
</body>
</html>
